package main

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/printer"
	"go/token"
	"io"

	"golang.org/x/tools/oracle"
)

var fileSet = &token.FileSet{}

func generateSumWalker(pkg *ast.Package, fileName string, ty *ast.TypeSpec) (*ast.File, error) {
	a, _ := parser.ParseFile(fileSet, "", `
		// DO NOT EDIT. Autogenerated with github.com/tcard/gosumwalk.

		package `+pkg.Name+`

		import "fmt"
`, parser.ParseComments)

	variants, err := findVariants(pkg, fileName, ty)
	if err != nil {
		return nil, fmt.Errorf("finding variants of type %v: %v", ty.Name, err)
	}

	gen := generator{a, ty, variants}
	gen.genWalker()

	return a, err
}

func printAST(w io.Writer, a *ast.File) error {
	return printer.Fprint(w, fileSet, a)
}

func findVariants(pkg *ast.Package, fileName string, ty *ast.TypeSpec) ([]variant, error) {
	res, err := oracle.Query(
		[]string{fileName},
		"implements",
		fmt.Sprintf("%v:#%v", fileName, ty.Pos()),
		nil, &build.Default, false)
	if err != nil {
		return nil, err
	}
	ret := []variant{}
	for _, x := range res.Serial().Implements.AssignableTo {
		isPtr := x.Kind == "pointer"
		offset := len(pkg.Name) + 1
		if isPtr {
			offset++
		}
		ret = append(ret, variant{x.Name[offset:], isPtr})
	}

	return ret, nil
}

type generator struct {
	a        *ast.File
	ty       *ast.TypeSpec
	variants []variant
}

func (gen generator) genWalker() {
	gen.genWalkFuncs()
	gen.genWalkerStructs()
	gen.genWalkerMaker()
	gen.genWalkerRunner()
	gen.genSignalDone()
}

func (gen generator) genWalkFuncs() {
	b := []ast.Stmt{
		&ast.AssignStmt{
			Lhs: []ast.Expr{&ast.Ident{Name: "w"}},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{&ast.CallExpr{
				Fun: &ast.Ident{Name: "new" + gen.ty.Name.Name + "Walker"},
			}},
		},
		&ast.GoStmt{Call: &ast.CallExpr{
			Fun: &ast.FuncLit{
				Type: &ast.FuncType{},
				Body: &ast.BlockStmt{List: []ast.Stmt{
					&ast.DeferStmt{Call: &ast.CallExpr{
						Fun: &ast.Ident{Name: "w.signalDone"},
					}},
					&ast.ExprStmt{&ast.CallExpr{
						Fun: &ast.Ident{Name: "run" + gen.ty.Name.Name + "Walker"},
						Args: []ast.Expr{
							&ast.Ident{Name: "w"},
							&ast.Ident{Name: "t"},
						},
					}},
				}},
			},
		}},
		&ast.ReturnStmt{
			Results: []ast.Expr{
				&ast.Ident{Name: "w"},
			},
		},
	}
	f := &ast.FuncDecl{
		Name: &ast.Ident{Name: "Walk" + gen.ty.Name.Name},
		Type: &ast.FuncType{
			Params: &ast.FieldList{List: []*ast.Field{{
				Names: []*ast.Ident{{Name: "t"}},
				Type:  &ast.Ident{Name: gen.ty.Name.Name},
			}}},
			Results: &ast.FieldList{List: []*ast.Field{{
				Type: &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
			}}},
		},
		Body: &ast.BlockStmt{List: b},
	}
	gen.a.Decls = append(gen.a.Decls, f)

}

func (gen generator) genWalkerStructs() {
	l := []*ast.Field{}
	for _, v := range gen.variants {
		name := ""
		if v.isPtr {
			name += "*"
		}
		name += v.name
		l = append(l, &ast.Field{
			Names: []*ast.Ident{{Name: v.name}},
			Type:  &ast.Ident{Name: "chan " + name},
		})
	}
	l = append(l, &ast.Field{
		Names: []*ast.Ident{{Name: "Done"}},
		Type:  &ast.Ident{Name: "chan struct{}"},
	})
	s := &ast.TypeSpec{
		Doc:  genComment("Walk."),
		Name: &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
		Type: &ast.StructType{
			Fields: &ast.FieldList{List: l},
		},
	}
	gen.a.Decls = append(gen.a.Decls, &ast.GenDecl{
		Tok:   token.TYPE,
		Specs: []ast.Spec{s},
	})
	gen.genWalkerMethods()
}

func (gen generator) genWalkerMethods() {
	gen.genIter()
}

func (gen generator) genIter() {
	b := []ast.Stmt{}
	for _, v := range gen.variants {
		b = append(b, &ast.CommClause{
			Comm: &ast.AssignStmt{
				Lhs: []ast.Expr{&ast.Ident{Name: "node"}},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{&ast.UnaryExpr{
					Op: token.ARROW,
					X:  &ast.Ident{Name: "w." + v.name},
				}},
			},
			Body: []ast.Stmt{
				&ast.SendStmt{
					Chan:  &ast.Ident{Name: "ch"},
					Value: &ast.Ident{Name: "node"},
				},
			},
		})
	}
	b = append(b, &ast.CommClause{
		Comm: &ast.ExprStmt{&ast.UnaryExpr{
			Op: token.ARROW,
			X:  &ast.Ident{Name: "w.Done"},
		}},
		Body: []ast.Stmt{
			&ast.ExprStmt{X: &ast.CallExpr{
				Fun:  &ast.Ident{Name: "close"},
				Args: []ast.Expr{&ast.Ident{Name: "ch"}},
			}},
		},
	})
	f := &ast.FuncDecl{
		Name: &ast.Ident{Name: "Iter"},
		Recv: &ast.FieldList{List: []*ast.Field{{
			Names: []*ast.Ident{{Name: "w"}},
			Type:  &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
		}}},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{List: []*ast.Field{{
				Type: &ast.Ident{Name: "<-chan " + gen.ty.Name.Name},
			}}},
		},
		Body: &ast.BlockStmt{List: []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{&ast.Ident{Name: "ch"}},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{&ast.Ident{Name: "make(chan " + gen.ty.Name.Name + ")"}},
			},
			&ast.GoStmt{Call: &ast.CallExpr{Fun: &ast.FuncLit{
				Type: &ast.FuncType{},
				Body: &ast.BlockStmt{List: []ast.Stmt{
					&ast.ForStmt{
						Body: &ast.BlockStmt{List: []ast.Stmt{
							&ast.SelectStmt{Body: &ast.BlockStmt{List: b}},
						}},
					},
				}},
			}}},
			&ast.ReturnStmt{
				Results: []ast.Expr{&ast.Ident{Name: "ch"}},
			},
		}},
	}
	gen.a.Decls = append(gen.a.Decls, f)
}

func (gen generator) genWalkerMaker() {
	elts := []ast.Expr{}
	for _, v := range gen.variants {
		name := v.name
		if v.isPtr {
			name = "*" + name
		}
		mk := &ast.CallExpr{
			Fun:  &ast.Ident{Name: "make"},
			Args: []ast.Expr{&ast.Ident{Name: "chan " + name}},
		}
		elts = append(elts, &ast.KeyValueExpr{
			Key:   &ast.Ident{Name: v.name},
			Value: mk,
		})
	}
	elts = append(elts, &ast.KeyValueExpr{
		Key: &ast.Ident{Name: "Done"},
		Value: &ast.CallExpr{
			Fun:  &ast.Ident{Name: "make"},
			Args: []ast.Expr{&ast.Ident{Name: "chan struct{}"}},
		},
	})
	b := []ast.Stmt{
		&ast.ReturnStmt{
			Results: []ast.Expr{
				&ast.CompositeLit{
					Type: &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
					Elts: elts,
				},
			},
		},
	}
	f := &ast.FuncDecl{
		Name: &ast.Ident{Name: "new" + gen.ty.Name.Name + "Walker"},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{List: []*ast.Field{{
				Type: &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
			}}},
		},
		Body: &ast.BlockStmt{List: b},
	}
	gen.a.Decls = append(gen.a.Decls, f)
}

func (gen generator) genWalkerRunner() {
	cases := []ast.Stmt{}
	for _, v := range gen.variants {
		name := v.name
		namePtr := name
		if v.isPtr {
			namePtr = "*" + namePtr
		}
		cases = append(cases, &ast.CaseClause{
			List: []ast.Expr{&ast.Ident{Name: namePtr}},
			Body: []ast.Stmt{
				&ast.SendStmt{
					Chan:  &ast.Ident{Name: "w." + name},
					Value: &ast.Ident{Name: "node"},
				},
			},
		})
	}
	cases = append(cases, &ast.CaseClause{
		Body: []ast.Stmt{&ast.ExprStmt{X: &ast.CallExpr{
			Fun: &ast.Ident{Name: "panic"},
			Args: []ast.Expr{&ast.Ident{
				Name: `fmt.Sprintf("Bad ` + gen.ty.Name.Name + ` type %T", node)`}},
		}}},
	})
	b := []ast.Stmt{
		&ast.TypeSwitchStmt{
			Assign: &ast.AssignStmt{
				Lhs: []ast.Expr{&ast.Ident{Name: "node"}},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{&ast.TypeAssertExpr{
					X:    &ast.Ident{Name: "t"},
					Type: &ast.Ident{Name: "type"},
				}},
			},
			Body: &ast.BlockStmt{List: cases},
		},
	}
	f := &ast.FuncDecl{
		Name: &ast.Ident{Name: "run" + gen.ty.Name.Name + "Walker"},
		Type: &ast.FuncType{
			Params: &ast.FieldList{List: []*ast.Field{
				{
					Names: []*ast.Ident{{Name: "w"}},
					Type:  &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
				},
				{
					Names: []*ast.Ident{{Name: "t"}},
					Type:  &ast.Ident{Name: gen.ty.Name.Name},
				},
			}},
		},
		Body: &ast.BlockStmt{List: b},
	}
	gen.a.Decls = append(gen.a.Decls, f)
}

func (gen generator) genSignalDone() {
	b := []ast.Stmt{
		&ast.SendStmt{
			Chan:  &ast.Ident{Name: "w.Done"},
			Value: &ast.Ident{Name: "struct{}{}"},
		},
	}
	for _, v := range gen.variants {
		b = append(b, &ast.ExprStmt{X: &ast.CallExpr{
			Fun:  &ast.Ident{Name: "close"},
			Args: []ast.Expr{&ast.Ident{Name: "w." + v.name}},
		}})
	}
	b = append(b, &ast.ExprStmt{X: &ast.CallExpr{
		Fun:  &ast.Ident{Name: "close"},
		Args: []ast.Expr{&ast.Ident{Name: "w.Done"}},
	}})
	f := &ast.FuncDecl{
		Name: &ast.Ident{Name: "signalDone"},
		Recv: &ast.FieldList{List: []*ast.Field{{
			Names: []*ast.Ident{{Name: "w"}},
			Type:  &ast.Ident{Name: gen.ty.Name.Name + "Walker"},
		}}},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
		},
		Body: &ast.BlockStmt{List: b},
	}
	gen.a.Decls = append(gen.a.Decls, f)
}

func genComment(ss ...string) *ast.CommentGroup {
	l := []*ast.Comment{}
	for _, s := range ss {
		l = append(l, &ast.Comment{Text: s})
	}
	return &ast.CommentGroup{List: l}
}

type variant struct {
	name  string
	isPtr bool
}
